{% include 'components/system_status_overview.html' %}

<!-- Dashboard metrics component -->
<div class="metrics-container">
  <div class="metrics-row">
    <!-- Metric Cards -->
    <div class="metric-card">
      <div class="card-header">
        <h3 class="card-title">Total Energy Yield Today</h3>
        <span class="card-icon">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z" />
          </svg>
        </span>
      </div>
      <div class="card-content">
        <p class="metric-value">45.23 kWh</p>
        <div class="metric-trend positive">
          <span class="trend-icon">↑</span>
          <span>+20.1%</span>
          <span class="trend-period">from yesterday</span>
        </div>
      </div>
    </div>

    <div class="metric-card">
      <div class="card-header">
        <h3 class="card-title">Total Devices</h3>
        <span class="card-icon">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <rect x="2" y="6" width="20" height="12" rx="2" />
            <path d="M12 12h.01" />
          </svg>
        </span>
      </div>
      <div class="card-content">
        <p class="metric-value">2,350</p>
        <div class="device-status">
          <span
            class="inline-flex items-center justify-center rounded-full bg-emerald-100 px-2.5 py-0.5 text-emerald-700"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              stroke-width="1.5"
              stroke="currentColor"
              class="-ms-1 me-1.5 size-4"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              />
            </svg>

            <p class="text-sm whitespace-nowrap">2,150 Online</p>
          </span>

          <span
            class="inline-flex items-center justify-center rounded-full bg-red-100 px-2.5 py-0.5 text-red-700"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              stroke-width="1.5"
              stroke="currentColor"
              class="-ms-1 me-1.5 size-4"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z"
              />
            </svg>

            <p class="text-sm whitespace-nowrap">200 Offline</p>
          </span>
        </div>
      </div>
    </div>

    <div class="metric-card">
      <div class="card-header">
        <h3 class="card-title">Total Faults</h3>
        <span class="card-icon">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path
              d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"
            />
            <line x1="12" y1="9" x2="12" y2="13" />
            <line x1="12" y1="17" x2="12.01" y2="17" />
          </svg>
        </span>
      </div>
      <div class="card-content">
        <p class="metric-value">24</p>
        <div class="flex flex-col gap-2">
          <div class="flex">
            <span
              class="inline-flex items-center justify-center rounded-full bg-red-100 px-2.5 py-0.5 text-red-700"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
                stroke-width="1.5"
                stroke="currentColor"
                class="-ms-1 me-1.5 size-4"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z"
                />
              </svg>
              <p class="text-sm whitespace-nowrap">Code Errors: 15</p>
            </span>
          </div>
          <div class="flex">
            <span
              class="inline-flex items-center justify-center rounded-full border border-red-500 px-2.5 py-0.5 text-red-700"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
                stroke-width="1.5"
                stroke="currentColor"
                class="-ms-1 me-1.5 size-4"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z"
                />
              </svg>
              <p class="text-sm whitespace-nowrap">Device Faults: 9</p>
            </span>
          </div>
        </div>
      </div>
    </div>

    <div class="metric-card">
      <div class="card-header">
        <h3 class="card-title">System Performance</h3>
        <span class="card-icon">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path d="M22 12h-4l-3 9L9 3l-3 9H2" />
          </svg>
        </span>
      </div>
      <div class="card-content">
        <p class="metric-value">98.6%</p>
        <div class="metric-trend positive">
          <span class="trend-icon">↑</span>
          <span>+1.4%</span>
          <span class="trend-period">from last week</span>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Energy Production Chart -->
<div
  class="chart-container mt-6"
  id="energy-production-chart"
  x-data="{ 
    activePeriod: 'day', 
    summaryText: 'Loading...', 
    periodComparison: '', 
    filters: [] 
  }"
>
  <div class="chart-card">
    <div class="card-header flex justify-between">
      <h3 class="card-title">Energy Yield Overview</h3>
      <div class="chart-controls">
        <div class="chart-period-info">
          <strong class="period-summary" x-text="summaryText"></strong>
          <span class="period-comparison" x-text="periodComparison"></span>
        </div>
        <select
          class="chart-period-selector"
          x-model="activePeriod"
          @change="handlePeriodChange($event.target.value)"
          id="period-selector"
        >
          <option value="day">Today</option>
          <option value="week">This Week</option>
          <option value="month">This Month</option>
          <option value="year">This Year</option>
        </select>
      </div>
    </div>
    <div class="chart-wrapper">
      <canvas id="energyProductionChart"></canvas>
    </div>
  </div>
</div>

<!-- Energy Prediction Chart -->
<div
  class="chart-container prediction-chart-container"
  id="energy-prediction-chart"
  x-data="{ 
    days: 7, 
    totalPrediction: '0.00', 
    isLoading: true,
    breakdownData: {}
  }"
>
  <div class="chart-card">
    <div
      class="card-header flex flex-col md:flex-row justify-between md:items-center space-y-3 md:space-y-0"
    >
      <h3 class="card-title text-lg font-semibold">Energy Yield Prediction</h3>
      <div
        class="chart-controls flex flex-col sm:flex-row items-start sm:items-center gap-3 md:gap-4 w-full md:w-auto"
      >
        <div class="chart-period-info w-full sm:w-auto">
          <div class="flex flex-wrap items-center gap-2">
            <span class="period-summary font-medium">
              <span
                x-show="isLoading"
                class="inline-block animate-pulse bg-gray-200 rounded h-4 w-20"
              ></span>
              <span x-show="!isLoading" class="whitespace-nowrap">
                Predicted yield:
                <strong class="text-indigo-600"
                  >{{ totalPrediction }} kWh</strong
                >
              </span>
            </span>
            <span
              class="badge bg-indigo-100 text-indigo-800 text-xs px-2 py-1 rounded-full"
            >
              Next <span x-text="days"></span> days
            </span>
          </div>
          <span
            class="period-comparison text-sm text-gray-500 italic block mt-1"
            >Based on historical data analysis</span
          >
        </div>
        <select
          class="prediction-period-selector w-full sm:w-auto min-w-[130px] bg-white border border-indigo-300 text-gray-700 py-1.5 px-3 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm"
          x-model="days"
          @change="$dispatch('fetch-data', days)"
          :disabled="isLoading"
        >
          <option value="7">Next 7 Days</option>
          <option value="14">Next 14 Days</option>
          <option value="30">Next 30 Days</option>
        </select>
      </div>
    </div>
    <div class="chart-wrapper relative mt-4 h-[300px] md:h-[400px]">
      <div
        x-show="isLoading"
        class="absolute inset-0 bg-white bg-opacity-70 flex items-center justify-center z-10"
      >
        <div
          class="loading-spinner h-8 w-8 border-4 border-indigo-200 border-t-indigo-600 rounded-full animate-spin"
        ></div>
      </div>
      <canvas id="energyPredictionChart"></canvas>
    </div>
    <div id="prediction-breakdown" class="mt-4 overflow-x-auto text-sm"></div>
  </div>
</div>

<!-- Power Distribution Chart -->
<div
  class="chart-container additional-charts"
  id="power-distribution-chart"
  x-data="{ selectedSegment: null }"
>
  <div class="chart-card">
    <div class="card-header">
      <h3 class="card-title">Power Distribution</h3>
      <div class="chart-controls" x-show="selectedSegment">
        <div class="selected-segment-info">
          <span>Selected: <strong x-text="selectedSegment"></strong></span>
          <button
            class="btn-close"
            @click="$dispatch('deselect-segment'); selectedSegment = null"
          >
            ×
          </button>
        </div>
      </div>
    </div>
    <div id="powerDistributionChart" style="height: 300px"></div>
  </div>
</div>

<!-- Required libraries -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
<script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>

<script>
  /**
   * Initialize energy production chart with current and previous period data
   * @returns {Chart|null} The initialized Chart.js instance or null
   */
  function initEnergyProductionChart() {
    // Get canvas context
    const ctx = document
      .getElementById("energyProductionChart")
      ?.getContext("2d");
    if (!ctx) return null;

    // Generate data
    let labels = [];
    let currentPeriodData = [];
    let previousPeriodData = [];

    // Get period from Alpine component
    const productionEl = document.getElementById("energy-production-chart");
    const period = productionEl?._x_dataStack?.[0]?.activePeriod || "day";

    // Generate data using utility if available
    if (window.EnergyDataUtils) {
      const today = new Date();
      const data = window.EnergyDataUtils.generateEnergyData(period, 10, today);

      // Current period data
      labels = data.labels;
      currentPeriodData = data.datasets.production;

      // Previous period data
      let prevDate = getPreviousPeriodDate(period);
      const prevData = window.EnergyDataUtils.generateEnergyData(
        period,
        9.5,
        prevDate
      );
      previousPeriodData = prevData.datasets.production;

      // Update summary text in Alpine component
      updateProductionChartSummary(
        productionEl,
        period,
        data.totals.production,
        prevData.totals.production
      );
    } else {
      // Fallback data generation
      labels = generateFallbackLabels(period);
      currentPeriodData = labels.map(() => Math.random() * 10 + 5);
      previousPeriodData = labels.map(() => Math.random() * 8 + 5);
    }

    // Create and return chart
    return new Chart(ctx, {
      type: "bar",
      data: {
        labels: labels,
        datasets: [
          {
            label: "Current Period",
            data: currentPeriodData,
            backgroundColor: "rgba(16, 185, 129, 0.7)",
            borderColor: "rgba(16, 185, 129, 1)",
            borderWidth: 1,
            borderRadius: 4,
            barPercentage: 0.6,
          },
          {
            label: "Previous Period",
            data: previousPeriodData,
            backgroundColor: "rgba(209, 213, 219, 0.5)",
            borderColor: "rgba(209, 213, 219, 0.8)",
            borderWidth: 1,
            borderRadius: 4,
            barPercentage: 0.6,
          },
        ],
      },
      options: getProductionChartOptions(),
    });
  }

  /**
   * Get chart options for production chart
   * @returns {Object} Chart.js options object
   */
  function getProductionChartOptions() {
    return {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: "bottom",
          labels: {
            usePointStyle: true,
            padding: 20,
          },
        },
        tooltip: {
          mode: "index",
          intersect: false,
          callbacks: {
            label: function (context) {
              let label = context.dataset.label || "";
              if (context.parsed.y !== null) {
                label += `: ${context.parsed.y.toFixed(2)} kWh`;
              }
              return label;
            },
          },
        },
      },
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: "Energy Production (kWh)",
          },
          grid: {
            color: "rgba(243, 244, 246, 0.7)",
          },
        },
        x: {
          grid: {
            display: false,
          },
        },
      },
    };
  }

  /**
   * Initialize energy prediction chart
   * @returns {Chart|null} The initialized Chart.js instance or null
   */
  function initPredictionChart() {
    const ctx = document
      .getElementById("energyPredictionChart")
      ?.getContext("2d");
    if (!ctx) return null;

    // Get prediction days from Alpine component
    const predictionEl = document.getElementById("energy-prediction-chart");
    const days = predictionEl?._x_dataStack?.[0]?.days || 7;

    // Generate date labels
    const labels = generateDateLabels(days);

    // Generate prediction data
    const {
      predictionData,
      historicalData,
      confidenceLow,
      confidenceHigh,
      efficiencyData,
      totalPrediction,
      weatherPattern,
      breakdownData,
    } = generatePredictionData(days);

    // Store data for tooltip access
    window.weatherPattern = weatherPattern;
    window.efficiencyData = efficiencyData;

    // Update Alpine component with prediction total
    updatePredictionSummary(predictionEl, totalPrediction);

    // Create prediction chart
    return new Chart(ctx, {
      type: "line",
      data: {
        labels: labels,
        datasets: [
          {
            label: "Predicted Energy",
            data: predictionData,
            borderColor: "rgba(79, 70, 229, 1)",
            backgroundColor: "rgba(79, 70, 229, 0.1)",
            borderWidth: 2,
            tension: 0.3,
            fill: false,
          },
          {
            label: "Historical Energy",
            data: historicalData,
            borderColor: "rgba(16, 185, 129, 1)",
            backgroundColor: "rgba(16, 185, 129, 0.5)",
            borderWidth: 2,
            pointRadius: 4,
            tension: 0,
            fill: false,
          },
          {
            label: "Confidence Interval",
            data: confidenceLow,
            borderColor: "rgba(209, 213, 219, 0)",
            backgroundColor: "rgba(209, 213, 219, 0.3)",
            borderWidth: 0,
            tension: 0.3,
            fill: "+1",
            pointRadius: 0,
          },
          {
            label: "Confidence Interval",
            data: confidenceHigh,
            borderColor: "rgba(209, 213, 219, 0)",
            backgroundColor: "rgba(209, 213, 219, 0.3)",
            tension: 0.3,
            fill: false,
            pointRadius: 0,
          },
        ],
      },
      options: getPredictionChartOptions(),
    });
  }

  /**
   * Initialize power distribution chart using ECharts
   */
  function initPowerDistributionChart() {
    if (typeof echarts === "undefined") {
      console.error("ECharts is not loaded");
      return null;
    }

    const chartElement = document.getElementById("powerDistributionChart");
    if (!chartElement) return null;

    const chart = echarts.init(chartElement);
    const chartData = generatePowerDistributionData();

    chart.setOption({
      tooltip: {
        trigger: "item",
        formatter: "{a} <br/>{b}: {c} kWh ({d}%)",
      },
      legend: {
        data: chartData.map((item) => item.name),
        bottom: 10,
        selectedMode: "single",
      },
      series: [
        {
          name: "Power Distribution",
          type: "pie",
          radius: ["50%", "70%"],
          avoidLabelOverlap: false,
          itemStyle: {
            borderRadius: 10,
            borderColor: "#fff",
            borderWidth: 2,
          },
          label: {
            show: false,
            position: "center",
          },
          emphasis: {
            label: {
              show: true,
              fontSize: "18",
              fontWeight: "bold",
            },
            itemStyle: {
              shadowBlur: 10,
              shadowOffsetX: 0,
              shadowColor: "rgba(0, 0, 0, 0.5)",
            },
          },
          labelLine: {
            show: false,
          },
          data: chartData,
        },
      ],
    });

    // Add segment click handler
    setupPowerDistributionClickHandler(chart);

    return chart;
  }

  // ------- Helper functions -------

  /**
   * Get previous period date based on current period
   */
  function getPreviousPeriodDate(period) {
    const prevDate = new Date();
    switch (period) {
      case "day":
        prevDate.setDate(prevDate.getDate() - 1);
        break;
      case "week":
        prevDate.setDate(prevDate.getDate() - 7);
        break;
      case "month":
        prevDate.setMonth(prevDate.getMonth() - 1);
        break;
      case "year":
        prevDate.setFullYear(prevDate.getFullYear() - 1);
        break;
    }
    return prevDate;
  }

  /**
   * Generate fallback labels when energy utility is not available
   */
  function generateFallbackLabels(period) {
    switch (period) {
      case "day":
        return Array.from({ length: 24 }, (_, i) => `${i}:00`);
      case "week":
        return ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
      case "month":
        return Array.from({ length: 30 }, (_, i) => `${i + 1}`);
      case "year":
        return [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec",
        ];
    }
  }

  /**
   * Update production chart summary in Alpine component
   */
  function updateProductionChartSummary(element, period, total, prevTotal) {
    if (element?._x_dataStack?.[0]) {
      // Create safe text content with strong tag for the value
      element._x_dataStack[0].summaryText = `Total ${period}: ${total} kWh`;

      // Calculate percentage difference
      const diffPercent = (((total - prevTotal) / prevTotal) * 100).toFixed(1);
      element._x_dataStack[0].periodComparison = `${
        diffPercent > 0 ? "+" : ""
      }${diffPercent}% from previous ${period}`;
    }
  }

  /**
   * Generate date labels for prediction chart
   */
  function generateDateLabels(days) {
    return Array.from({ length: days }, (_, i) => {
      const date = new Date();
      date.setDate(date.getDate() + i);
      return date.toLocaleDateString("en-US", {
        month: "short",
        day: "numeric",
      });
    });
  }

  /**
   * Generate prediction data for the chart
   */
  function generatePredictionData(days) {
    if (window.EnergyDataUtils) {
      const today = new Date();
      const month = today.getMonth();
      const seasonalFactor = window.EnergyDataUtils.getSeasonalFactor(month);

      // Enhanced prediction model with weather patterns
      const weatherPattern = generateWeatherPattern(days);
      const seasonalTrend = getSeasonalTrend(today, days);

      // Generate daily predictions with more sophisticated patterns
      const predictionData = Array.from({ length: days }, (_, index) => {
        const dayFactor = 1 + Math.sin((index / days) * Math.PI) * 0.2;
        const randomFactor = 0.9 + Math.random() * 0.2;
        const weatherFactor = weatherPattern[index];
        const seasonalImpact = seasonalTrend[index];

        return +(
          seasonalFactor *
          10 *
          dayFactor *
          randomFactor *
          weatherFactor *
          seasonalImpact
        ).toFixed(2);
      });

      // Generate historical data (only for past days)
      const historicalData = Array.from({ length: days }, (_, index) => {
        if (index < 2) {
          const dayFactor = 1 + Math.sin((index / days) * Math.PI) * 0.2;
          const randomFactor = 0.9 + Math.random() * 0.2;
          return +(seasonalFactor * 10 * dayFactor * randomFactor).toFixed(2);
        }
        return null; // No historical data for future days
      });

      // Generate confidence intervals with more realistic fluctuations
      const confidenceVariance = generateConfidenceVariance(days);
      const confidenceLow = predictionData.map(
        (val, i) => +(val * (0.8 - confidenceVariance[i] * 0.1)).toFixed(2)
      );
      const confidenceHigh = predictionData.map(
        (val, i) => +(val * (1.2 + confidenceVariance[i] * 0.1)).toFixed(2)
      );

      // Calculate efficiency predictions
      const efficiencyData = predictionData.map(
        (val) => +(val * 0.85).toFixed(2)
      );

      const totalPrediction = predictionData
        .reduce((sum, val) => sum + val, 0)
        .toFixed(2);

      // Calculate breakdown data for different components
      const breakdownData = {
        optimal: predictionData.reduce((sum, val) => sum + val, 0),
        weatherImpact: predictionData.reduce(
          (sum, val, i) => sum + val * (1 - weatherPattern[i]),
          0
        ),
        systemEfficiency: predictionData.reduce(
          (sum, val) => sum + val * 0.15,
          0
        ),
      };

      return {
        predictionData,
        historicalData,
        confidenceLow,
        confidenceHigh,
        efficiencyData,
        totalPrediction,
        weatherPattern,
        breakdownData,
      };
    }

    // Fallback when utility is not available
    return {
      predictionData: Array.from(
        { length: days },
        () => Math.random() * 10 + 5
      ),
      historicalData: Array.from({ length: days }, (_, i) =>
        i < 2 ? Math.random() * 10 + 5 : null
      ),
      confidenceLow: Array.from({ length: days }, () => Math.random() * 8),
      confidenceHigh: Array.from(
        { length: days },
        () => Math.random() * 12 + 8
      ),
      efficiencyData: Array.from({ length: days }, () => Math.random() * 8 + 4),
      totalPrediction: (Math.random() * 100 + 50).toFixed(2),
      weatherPattern: Array.from(
        { length: days },
        () => Math.random() * 0.3 + 0.7
      ),
      breakdownData: {
        optimal: Math.random() * 100 + 50,
        weatherImpact: Math.random() * 20 + 5,
        systemEfficiency: Math.random() * 10 + 5,
      },
    };
  }

  /**
   * Generate weather pattern for given days
   */
  function generateWeatherPattern(days) {
    // Generate a semi-realistic weather pattern with some consecutive similar days
    let pattern = [];
    let currentWeather = 0.9 + Math.random() * 0.1; // Start with good weather

    for (let i = 0; i < days; i++) {
      // 20% chance of weather change
      if (Math.random() < 0.2) {
        // Generate new weather value between 0.7 (cloudy) and 1.0 (sunny)
        currentWeather = 0.7 + Math.random() * 0.3;
      } else {
        // Slight random variation to current weather
        currentWeather += (Math.random() - 0.5) * 0.05;
        // Clamp between 0.7 and 1.0
        currentWeather = Math.max(0.7, Math.min(1.0, currentWeather));
      }
      pattern.push(currentWeather);
    }

    return pattern;
  }

  /**
   * Generate seasonal trend based on current date
   */
  function getSeasonalTrend(startDate, days) {
    const trend = [];
    const currentDate = new Date(startDate);

    for (let i = 0; i < days; i++) {
      currentDate.setDate(currentDate.getDate() + 1);
      const month = currentDate.getMonth();

      // Seasonal factor based on month (northern hemisphere)
      // Higher in summer months, lower in winter
      let seasonalFactor;
      if (month >= 4 && month <= 8) {
        // May-Sep: summer
        seasonalFactor = 1 + Math.random() * 0.1;
      } else if (month >= 2 && month <= 3) {
        // Mar-Apr: spring
        seasonalFactor = 0.95 + Math.random() * 0.1;
      } else if (month >= 9 && month <= 10) {
        // Oct-Nov: fall
        seasonalFactor = 0.9 + Math.random() * 0.1;
      } else {
        // Dec-Feb: winter
        seasonalFactor = 0.8 + Math.random() * 0.1;
      }

      trend.push(seasonalFactor);
    }

    return trend;
  }

  /**
   * Generate variance values for confidence intervals
   */
  function generateConfidenceVariance(days) {
    // Generate some semi-random variance values
    const variance = [];
    let currentVariance = Math.random() * 0.5;

    for (let i = 0; i < days; i++) {
      // Slight random variation to variance
      currentVariance += (Math.random() - 0.5) * 0.1;
      // Clamp between 0 and 0.5
      currentVariance = Math.max(0, Math.min(0.5, currentVariance));
      variance.push(currentVariance);
    }

    return variance;
  }

  /**
   * Update prediction summary in Alpine component with enhanced data
   */
  function updatePredictionSummary(element, totalPrediction) {
    if (element?._x_dataStack?.[0]) {
      element._x_dataStack[0].totalPrediction = totalPrediction;
      element._x_dataStack[0].isLoading = false;

      // If we have the breakdownData available, update with details
      if (element._x_data && element._x_data.breakdownData) {
        element._x_data.breakdownData = {
          optimal: totalPrediction,
          weatherImpact: (totalPrediction * 0.15).toFixed(2),
          systemEfficiency: (totalPrediction * 0.1).toFixed(2),
        };
      }
    }
  }

  /**
   * Get chart options for prediction chart
   */
  function getPredictionChartOptions() {
    return {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: "bottom",
          labels: {
            filter: function (item) {
              // Hide confidence interval from legend
              return !item.text.includes("Confidence");
            },
            usePointStyle: true,
            padding: 20,
          },
        },
        tooltip: {
          mode: "index",
          intersect: false,
          callbacks: {
            label: function (context) {
              let label = context.dataset.label || "";
              if (context.parsed.y !== null) {
                label += label
                  ? `: ${context.parsed.y.toFixed(2)} kWh`
                  : context.parsed.y.toFixed(2) + " kWh";
              }

              // Add weather impact info for predicted energy
              if (
                label.includes("Predicted") &&
                context.dataIndex !== undefined
              ) {
                const weatherImpact =
                  window.weatherPattern?.[context.dataIndex] || 0;
                if (weatherImpact < 0.8) {
                  label += ` (Weather impact: -${(
                    (1 - weatherImpact) *
                    100
                  ).toFixed(0)}%)`;
                }
              }

              return label;
            },
            footer: function (tooltipItems) {
              // Add efficiency note if available
              const dataIndex = tooltipItems[0].dataIndex;
              const efficiencyValue = window.efficiencyData?.[dataIndex];
              const dataValue = tooltipItems[0].raw;
              const weatherImpact = window.weatherPattern?.[dataIndex] || 0;

              const footerLines = [];

              // System efficiency info
              if (efficiencyValue) {
                const efficiencyPercent = Math.round(
                  (efficiencyValue / dataValue) * 100
                );
                footerLines.push(`System efficiency: ${efficiencyPercent}%`);

                if (efficiencyPercent < 90) {
                  footerLines.push(
                    `Potential gain: +${(dataValue - efficiencyValue).toFixed(
                      2
                    )} kWh with optimized efficiency`
                  );
                }
              }

              // Weather condition details
              if (weatherImpact) {
                let weatherCondition = "";
                if (weatherImpact > 0.95)
                  weatherCondition = "Optimal solar conditions";
                else if (weatherImpact > 0.85)
                  weatherCondition = "Good solar conditions";
                else if (weatherImpact > 0.75)
                  weatherCondition = "Fair solar conditions";
                else weatherCondition = "Poor solar conditions";

                footerLines.push(weatherCondition);
              }

              // Add performance rating
              const performanceRating = calculatePerformanceRating(
                weatherImpact,
                efficiencyValue / dataValue
              );
              footerLines.push(
                `Daily performance rating: ${performanceRating}`
              );

              return footerLines;
            },
          },
        },
      },
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: "Energy (kWh)",
          },
          grid: {
            color: "rgba(243, 244, 246, 0.7)",
          },
        },
        x: {
          grid: {
            display: false,
          },
        },
      },
      interaction: {
        mode: "index",
        intersect: false,
      },
    };
  }

  /**
   * Fetch prediction data for the given number of days
   */
  function fetchPredictionData(chart, days) {
    const predictionEl = document.getElementById("energy-prediction-chart");
    if (!predictionEl?._x_dataStack?.[0]) return;

    // Set loading state
    predictionEl._x_dataStack[0].isLoading = true;

    // Generate new prediction data
    const labels = generateDateLabels(days);
    const {
      predictionData,
      historicalData,
      confidenceLow,
      confidenceHigh,
      efficiencyData,
      totalPrediction,
      weatherPattern,
      breakdownData,
    } = generatePredictionData(days);

    // Store data for tooltip access
    window.weatherPattern = weatherPattern;
    window.efficiencyData = efficiencyData;

    // Update chart data
    chart.data.labels = labels;
    chart.data.datasets[0].data = predictionData;
    chart.data.datasets[1].data = historicalData;
    chart.data.datasets[2].data = confidenceLow;
    chart.data.datasets[3].data = confidenceHigh;

    // Update Alpine component data
    if (predictionEl._x_dataStack[0]) {
      predictionEl._x_dataStack[0].breakdownData = breakdownData;
    }

    // Update chart
    chart.update();

    // Update summary
    updatePredictionSummary(predictionEl, totalPrediction);

    // Add detailed breakdown if it exists
    updatePredictionBreakdown(predictionEl, breakdownData, days);
  }

  /**
   * Update prediction breakdown details
   */
  function updatePredictionBreakdown(element, breakdownData, days) {
    const breakdownEl = document.getElementById("prediction-breakdown");
    if (!breakdownEl) return;

    // Format the breakdown data
    const optimalValue = breakdownData.optimal.toFixed(2);
    const weatherImpactValue = breakdownData.weatherImpact.toFixed(2);
    const efficiencyValue = breakdownData.systemEfficiency.toFixed(2);
    const netPrediction = (
      breakdownData.optimal -
      breakdownData.weatherImpact -
      breakdownData.systemEfficiency
    ).toFixed(2);

    // Update the breakdown element
    breakdownEl.innerHTML = `
      <div class="prediction-factors mt-3 text-sm">
        <div class="factor-row flex justify-between border-b border-gray-200 py-1">
          <span class="font-medium">Optimal production (${days} days):</span>
          <span>${optimalValue} kWh</span>
        </div>
        <div class="factor-row flex justify-between border-b border-gray-200 py-1 text-amber-700">
          <span>Weather impact:</span>
          <span>-${weatherImpactValue} kWh</span>
        </div>
        <div class="factor-row flex justify-between border-b border-gray-200 py-1 text-amber-700">
          <span>System efficiency loss:</span>
          <span>-${efficiencyValue} kWh</span>
        </div>
        <div class="factor-row flex justify-between py-1 font-medium">
          <span>Net predicted production:</span>
          <span>${netPrediction} kWh</span>
        </div>
      </div>
    `;
  }

  /**
   * Deselect segment in power distribution chart
   */
  function deselectSegment(chart) {
    if (chart && typeof chart.dispatchAction === "function") {
      chart.dispatchAction({
        type: "downplay",
        seriesIndex: 0,
      });
    }
  }

  /**
   * Calculate performance rating based on weather and efficiency
   */
  function calculatePerformanceRating(weatherImpact, efficiencyRatio) {
    if (!weatherImpact || !efficiencyRatio) return "N/A";

    const combinedScore = weatherImpact * 0.4 + efficiencyRatio * 0.6;

    if (combinedScore > 0.9) return "Excellent";
    if (combinedScore > 0.8) return "Very Good";
    if (combinedScore > 0.7) return "Good";
    if (combinedScore > 0.6) return "Fair";
    return "Poor";
  }

  /**
   * Initialize all charts when DOM is ready
   */
  document.addEventListener("DOMContentLoaded", function () {
    // Load energy chart utilities if not already available
    if (!window.EnergyDataUtils) {
      const script = document.createElement("script");
      script.src = "/static/js/energy_chart.js";
      script.onload = initAllCharts;
      document.head.appendChild(script);
    } else {
      initAllCharts();
    }

    // Set up the period selector event handler
    setupPeriodSelector();
  });

  /**
   * Set up the period selector event handling
   */
  function setupPeriodSelector() {
    const periodSelector = document.getElementById("period-selector");
    if (periodSelector) {
      periodSelector.addEventListener("change", function (event) {
        const selectedPeriod = event.target.value;
        if (window.energyProductionChart) {
          handlePeriodChange(window.energyProductionChart, selectedPeriod);
        }
      });
    }
  }

  /**
   * Handle period change for the production chart
   * @param {Chart} chart - The Chart.js instance
   * @param {string} period - The selected period (day, week, month, year)
   */
  function handlePeriodChange(chart, period) {
    // Generate data for the new period
    const today = new Date();
    let labels = [];
    let currentPeriodData = [];
    let previousPeriodData = [];

    // Generate data using utility if available
    if (window.EnergyDataUtils) {
      const data = window.EnergyDataUtils.generateEnergyData(period, 10, today);

      // Current period data
      labels = data.labels;
      currentPeriodData = data.datasets.production;

      // Previous period data
      let prevDate = getPreviousPeriodDate(period);
      const prevData = window.EnergyDataUtils.generateEnergyData(
        period,
        9.5,
        prevDate
      );
      previousPeriodData = prevData.datasets.production;

      // Update summary in Alpine component
      const productionEl = document.getElementById("energy-production-chart");
      updateProductionChartSummary(
        productionEl,
        period,
        data.totals.production,
        prevData.totals.production
      );
    } else {
      // Fallback data generation
      labels = generateFallbackLabels(period);
      currentPeriodData = labels.map(() => Math.random() * 10 + 5);
      previousPeriodData = labels.map(() => Math.random() * 8 + 5);
    }

    // Update chart data
    chart.data.labels = labels;
    chart.data.datasets[0].data = currentPeriodData;
    chart.data.datasets[1].data = previousPeriodData;
    chart.update();
  }

  /**
   * Initialize all chart components and set up event handlers
   */
  function initAllCharts() {
    try {
      // Register Chart.js plugins if available
      if (
        typeof Chart !== "undefined" &&
        typeof ChartDataLabels !== "undefined"
      ) {
        Chart.register(ChartDataLabels);
      }

      // Initialize energy production chart
      const productionEl = document.getElementById("energy-production-chart");
      let energyProductionChart = null;

      if (productionEl && document.getElementById("energyProductionChart")) {
        energyProductionChart = initEnergyProductionChart();
        // Store chart in global scope for access by period selector
        window.energyProductionChart = energyProductionChart;
      }

      // Initialize prediction chart
      const predictionEl = document.getElementById("energy-prediction-chart");
      let predictionChart = null;

      if (predictionEl && document.getElementById("energyPredictionChart")) {
        predictionChart = initPredictionChart();

        // Set up event listeners
        predictionEl.addEventListener("fetch-data", (event) => {
          if (predictionChart)
            fetchPredictionData(predictionChart, event.detail);
        });
      }

      // Initialize power distribution chart
      const powerDistEl = document.getElementById("power-distribution-chart");
      let powerDistributionChart = null;

      if (powerDistEl && document.getElementById("powerDistributionChart")) {
        powerDistributionChart = initPowerDistributionChart();

        // Set up event listeners
        powerDistEl.addEventListener("deselect-segment", () => {
          if (powerDistributionChart) deselectSegment(powerDistributionChart);
        });
      }

      // Handle window resize for all charts
      window.addEventListener("resize", function () {
        [energyProductionChart, predictionChart].forEach((chart) => {
          if (chart) chart.resize();
        });

        if (
          powerDistributionChart &&
          typeof powerDistributionChart.resize === "function"
        ) {
          powerDistributionChart.resize();
        }
      });
    } catch (error) {
      console.error("Error initializing charts:", error);
    }
  }
</script>
