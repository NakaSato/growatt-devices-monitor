<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no"
    />
    <meta
      name="description"
      content="Growatt API - Monitor your solar energy production and devices"
    />
    <meta
      name="keywords"
      content="Growatt, solar energy, monitoring, API, renewable energy"
    />
    <meta name="author" content="Growatt API" />
    <meta name="robots" content="index, follow" />
    <link rel="canonical" href="{{ request.url }}" />
    <meta name="theme-color" content="#ffffff" />

    <!-- Favicon -->
    <link
      rel="icon"
      href="{{ url_for('static', filename='favicon.ico') }}?_ts={{ now|default(None) or config.get('LAST_UPDATE', '') or range(1, 9999)|random }}"
    />

    <!-- Google Fonts - Noto Sans Thai -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+Thai:wght@100..900&display=swap"
      rel="stylesheet"
    />

    <!-- Alpine.js Plugins -->
    <script
      defer
      src="https://unpkg.com/@alpinejs/intersect@3.x.x/dist/cdn.min.js"
    ></script>
    <script
      defer
      src="https://unpkg.com/@alpinejs/persist@3.x.x/dist/cdn.min.js"
    ></script>
    <script
      defer
      src="https://unpkg.com/@alpinejs/collapse@3.x.x/dist/cdn.min.js"
    ></script>

    <!-- Alpine.js Core -->
    <script
      defer
      src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"
    ></script>

    <!-- Ensure Alpine plugins are registered -->
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        if (window.Alpine) {
          // This will be executed after Alpine is loaded
          // If there's a timing issue, the plugin registration will happen on alpine:init
        }
      });

      document.addEventListener("alpine:init", function () {
        // Ensure plugins are properly registered
        if (
          window.Alpine &&
          window.AlpineCollapse &&
          !Alpine.hasOwnProperty("collapse")
        ) {
          Alpine.plugin(AlpineCollapse);
        }
      });
    </script>

    <!-- Component Loader -->
    <script src="{{ url_for('static', filename='js/component-loader.js') }}?_ts={{ now|default(None) or config.get('LAST_UPDATE', '') or range(1, 9999)|random }}"></script>

    <!-- Responsive Utilities -->
    <script src="{{ url_for('static', filename='js/utils/responsive-utils.js') }}?_ts={{ now|default(None) or config.get('LAST_UPDATE', '') or range(1, 9999)|random }}"></script>

    <!-- Data Formatter Utilities -->
    <script src="{{ url_for('static', filename='js/utils/data-formatter.js') }}?_ts={{ now|default(None) or config.get('LAST_UPDATE', '') or range(1, 9999)|random }}"></script>

    <!-- Font Awesome -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
    />

    <!-- Tailwind Configuration -->
    <script src="{{ url_for('static', filename='js/config/tailwind-config.js') }}?_ts={{ now|default(None) or config.get('LAST_UPDATE', '') or range(1, 9999)|random }}"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com/3.4.16"></script>
    <script>
      // Set Tailwind configuration from our external file
      tailwind.config = window.tailwindConfig || {};
    </script>

    <!-- Custom CSS -->
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='css/style.css') }}?_ts={{ now|default(None) or config.get('LAST_UPDATE', '') or range(1, 9999)|random }}"
    />

    <title>
      {% block title %}Growatt API - Solar Monitoring System{% endblock %}
    </title>
    <!-- Open Graph tags for social media sharing -->
    <meta property="og:title" content="Growatt API - Solar Monitoring System" />
    <meta
      property="og:description"
      content="Monitor and analyze your Growatt solar energy production and devices"
    />
    <meta property="og:url" content="{{ request.url }}" />
    <meta property="og:type" content="website" />

    <!-- Page-specific styles -->
    {% block styles %}{% endblock %}

    <!-- Custom JavaScript block -->
    {% block head_scripts %}{% endblock %}

    <!-- Component Registration -->
    <script>
      document.addEventListener("alpine:init", () => {
        // Register global components
        Alpine.data("componentRegistry", () => ({
          components: {},

          registerComponent(name, callback) {
            this.components[name] = callback;
            return this;
          },

          getComponent(name) {
            return this.components[name] || (() => ({}));
          },
        }));

        // Add useful directives
        Alpine.directive("lazy-load", (el, { expression }, { evaluate }) => {
          const src = evaluate(expression);
          const observer = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                if (el.tagName === "IMG") {
                  el.src = src;
                } else {
                  el.style.backgroundImage = `url(${src})`;
                }
                observer.disconnect();
              }
            });
          });
          observer.observe(el);
        });
      });
    </script>
  </head>

  <body class="h-lvh max-h-screen">
    <!-- Header and Navigation -->
    {% include 'components/navbar.html' %}

    <main
      class="lg:container lg:mx-auto sm:px-0 lg:px-4 py-2 sm:py-2 lg:py-0 flex-grow"
    >
      {% block content %}{% endblock %}
    </main>

    {% include 'components/footer.html' %}

    <!-- Custom JavaScript at end of body -->
    {% block scripts %}{% endblock %}

    <script>
      // API Request Cache System
      window.apiCache = {
        // Default cache duration (5 minutes)
        defaultCacheDuration: 5 * 60 * 1000,

        // Get cached response if valid
        get: function (url, timestamp, maxAge) {
          const cacheKey = `api_cache_${url}`;
          const cachedData = localStorage.getItem(cacheKey);

          if (!cachedData) return null;

          try {
            const parsed = JSON.parse(cachedData);
            const cacheAge = (timestamp || Date.now()) - parsed.timestamp;
            const maxCacheAge = maxAge || this.defaultCacheDuration;

            // Check if cache is still valid
            if (cacheAge < maxCacheAge) {
              console.log(
                `Using cached data for ${url} (age: ${Math.round(
                  cacheAge / 1000
                )}s)`
              );
              return parsed.data;
            } else {
              console.log(
                `Cache expired for ${url} (age: ${Math.round(
                  cacheAge / 1000
                )}s)`
              );
              return null;
            }
          } catch (err) {
            console.warn("Invalid cache data for", url, err);
            return null;
          }
        },

        // Store response in cache with timestamp
        set: function (url, data, timestamp) {
          const cacheKey = `api_cache_${url}`;
          try {
            localStorage.setItem(
              cacheKey,
              JSON.stringify({
                timestamp: timestamp || Date.now(),
                data: data,
              })
            );
            console.log(`Cached data for ${url}`);
          } catch (err) {
            console.warn("Failed to cache data:", err);
          }
        },

        // Clear specific or all cached responses
        clear: function (url) {
          if (url) {
            localStorage.removeItem(`api_cache_${url}`);
            console.log(`Cleared cache for ${url}`);
          } else {
            Object.keys(localStorage).forEach((key) => {
              if (key.startsWith("api_cache_")) {
                localStorage.removeItem(key);
              }
            });
            console.log("Cleared all API cache");
          }
        },

        // Fetch with caching
        fetch: async function (url, options = {}) {
          const timestamp = Date.now();
          const {
            forceFresh = false,
            cacheDuration = this.defaultCacheDuration,
            requestOptions = {},
          } = options;

          // Try to get from cache unless force refresh is requested
          if (!forceFresh) {
            const cachedData = this.get(url, timestamp, cacheDuration);
            if (cachedData) return cachedData;
          }

          // Add timestamp to URL to bypass browser cache if needed
          const urlWithTimestamp = options.bypassBrowserCache
            ? `${url}${url.includes("?") ? "&" : "?"}_t=${timestamp}`
            : url;

          try {
            // Fetch fresh data
            const response = await fetch(urlWithTimestamp, {
              headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
                ...requestOptions.headers,
              },
              ...requestOptions,
            });

            if (!response.ok) {
              throw new Error(`Request failed with status ${response.status}`);
            }

            // Check content type to ensure it's JSON
            const contentType = response.headers.get("content-type");
            if (contentType && contentType.includes("application/json")) {
              const data = await response.json();

              // Cache the successful response
              this.set(url, data, timestamp);

              return data;
            } else {
              // Non-JSON responses are not cached
              return await response.text();
            }
          } catch (error) {
            console.error(`API fetch error for ${url}:`, error);
            throw error;
          }
        },
      };

      // Function to handle API access with improved error handling and user feedback
      document.addEventListener("DOMContentLoaded", () => {
        // Set CSS variable for viewport height to handle mobile browsers better
        function setViewportHeight() {
          let vh = window.innerHeight * 0.01;
          document.documentElement.style.setProperty("--vh", `${vh}px`);
        }

        // Set initial viewport height and update on resize
        setViewportHeight();
        window.addEventListener("resize", setViewportHeight);

        const apiAccessLink = document.getElementById("api-access-link");
        if (apiAccessLink) {
          apiAccessLink.addEventListener("click", requestApiAccess);
        }

        // Initialize component loader
        if (window.ComponentLoader) {
          window.componentLoader = new ComponentLoader({
            templatePath: "/templates/components/",
            cacheDuration: 3600, // 1 hour cache
            onError: (err) => console.error("Component loading error:", err),
          });
        }
      });

      function requestApiAccess(event) {
        if (event) {
          event.preventDefault();
        }

        // Show loading state to user
        const originalLinkText = event.target.textContent;
        event.target.textContent = "Loading...";
        event.target.classList.add("opacity-50");

        fetch("/api/access", {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
          },
          credentials: "same-origin",
        })
          .then((response) => {
            // Check if the content-type is JSON
            const contentType = response.headers.get("content-type");

            if (!response.ok) {
              if (contentType && contentType.includes("text/html")) {
                window.location.href = response.url;
                throw new Error("Session expired. Redirecting to login...");
              }
              throw new Error(`Request failed with status ${response.status}`);
            }

            // Check if response is JSON before trying to parse it
            if (contentType && contentType.includes("application/json")) {
              return response.json();
            } else {
              // Handle redirect instruction from JSON response
              return { status: "redirect", url: "/plants" };
            }
          })
          .then((data) => {
            if (data.status === "success") {
              // Show success message before redirect
              console.log("Authentication successful");
              setTimeout(() => (window.location.href = "/plants"), 800);
            } else if (data.status === "redirect") {
              window.location.href = data.url || "/plants";
            } else {
              throw new Error(data.message || "Failed to authenticate");
            }
          })
          .catch((error) => {
            console.error("API access error:", error);
            // Only show alert for errors that aren't redirects
            if (!error.message.includes("Redirecting to login")) {
              alert("Failed to access API: " + error.message);
            }
          })
          .finally(() => {
            // Reset button state
            event.target.textContent = originalLinkText;
            event.target.classList.remove("opacity-50");
          });
      }

      // Function to clear cache and session before logout
      function clearCacheAndLogout() {
        // Clear browser cache and storage
        localStorage.clear();
        sessionStorage.clear();

        // Clear cookies by setting expiration to past date
        document.cookie.split(";").forEach(function (c) {
          document.cookie = c
            .replace(/^ +/, "")
            .replace(
              /=.*/,
              "=;expires=" + new Date().toUTCString() + ";path=/"
            );
        });

        // Attempt to clear application cache if supported
        if (window.caches) {
          caches.keys().then(function (names) {
            for (let name of names) caches.delete(name);
          });
        }

        // Finally redirect to logout URL
        window.location.href = "/api/logout";
      }

      // Add responsive screen detection with enhanced breakpoints
      const breakpoints = {
        xs: 320,
        sm: 640,
        md: 768,
        lg: 1024,
        xl: 1280,
        "2xl": 1536,
      };

      // Create responsive state object
      window.responsive = {
        breakpoints,
        current: "",
        width: window.innerWidth,
        isXs: false,
        isSm: false,
        isMd: false,
        isLg: false,
        isXl: false,
        is2xl: false,
        isMobile: false,
        isTablet: false,
        isDesktop: false,
        isPortrait: window.matchMedia("(orientation: portrait)").matches,
        isLandscape: window.matchMedia("(orientation: landscape)").matches,
        isDarkMode: window.matchMedia("(prefers-color-scheme: dark)").matches,
        isReducedMotion: window.matchMedia("(prefers-reduced-motion: reduce)")
          .matches,
        isTouch: "ontouchstart" in window || navigator.maxTouchPoints > 0,
        supportsHover: window.matchMedia("(hover: hover)").matches,
      };

      // Update responsive state based on current viewport
      function updateResponsiveState() {
        const width = window.innerWidth;
        window.responsive.width = width;

        // Update breakpoint flags
        window.responsive.isXs =
          width >= breakpoints.xs && width < breakpoints.sm;
        window.responsive.isSm =
          width >= breakpoints.sm && width < breakpoints.md;
        window.responsive.isMd =
          width >= breakpoints.md && width < breakpoints.lg;
        window.responsive.isLg =
          width >= breakpoints.lg && width < breakpoints.xl;
        window.responsive.isXl =
          width >= breakpoints.xl && width < breakpoints["2xl"];
        window.responsive.is2xl = width >= breakpoints["2xl"];

        // Update device type flags
        window.responsive.isMobile = width < breakpoints.md;
        window.responsive.isTablet =
          width >= breakpoints.md && width < breakpoints.lg;
        window.responsive.isDesktop = width >= breakpoints.lg;

        // Set current breakpoint name
        if (width < breakpoints.sm) window.responsive.current = "xs";
        else if (width < breakpoints.md) window.responsive.current = "sm";
        else if (width < breakpoints.lg) window.responsive.current = "md";
        else if (width < breakpoints.xl) window.responsive.current = "lg";
        else if (width < breakpoints["2xl"]) window.responsive.current = "xl";
        else window.responsive.current = "2xl";

        // Update orientation
        window.responsive.isPortrait = window.matchMedia(
          "(orientation: portrait)"
        ).matches;
        window.responsive.isLandscape = window.matchMedia(
          "(orientation: landscape)"
        ).matches;

        // Dispatch custom event when responsive state changes
        window.dispatchEvent(
          new CustomEvent("responsive-changed", {
            detail: window.responsive,
          })
        );

        // Add responsive classes to body for CSS targeting
        document.body.classList.remove(
          "screen-xs",
          "screen-sm",
          "screen-md",
          "screen-lg",
          "screen-xl",
          "screen-2xl"
        );
        document.body.classList.add(`screen-${window.responsive.current}`);

        // Add device type classes
        document.body.classList.remove(
          "device-mobile",
          "device-tablet",
          "device-desktop"
        );
        if (window.responsive.isMobile)
          document.body.classList.add("device-mobile");
        else if (window.responsive.isTablet)
          document.body.classList.add("device-tablet");
        else document.body.classList.add("device-desktop");
      }

      // Initialize responsive state
      updateResponsiveState();

      // Update on resize with debounce
      let resizeTimer;
      window.addEventListener("resize", function () {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(updateResponsiveState, 100);
      });

      // Update on orientation change
      window.addEventListener("orientationchange", updateResponsiveState);

      // Listen for dark mode changes
      window
        .matchMedia("(prefers-color-scheme: dark)")
        .addEventListener("change", (e) => {
          window.responsive.isDarkMode = e.matches;
        });

      // For backwards compatibility
      window.isSmallScreen = window.responsive.isMobile;
      window.isMediumScreen = window.responsive.isTablet;
      window.isLargeScreen = window.responsive.isDesktop;
    </script>
  </body>
</html>
