{% extends "base.html" %} {% block title %}Weather Status - Growatt API{%
endblock %} {% block content %}
<div id="weather-app" v-cloak>
  <h1>Weather Status for Plant: {{ plant_name }}</h1>

  <!-- Loading spinner -->
  <div
    :class="{'spinner': true}"
    :style="{ display: isLoading ? 'block' : 'none' }"
  ></div>

  <!-- Export Button -->
  <button class="btn btn-primary" @click="exportToExcel">
    Export to Excel
  </button>

  <!-- Weather Chart Visualization -->
  <div class="weather-chart-container">
    <h2>Weather Trends</h2>
    <div class="chart-controls">
      <select v-model="chartMetric" @change="updateChart">
        <option value="temperature">Temperature</option>
        <option value="humidity">Humidity</option>
        <option value="weather">Weather Conditions</option>
      </select>
      <select v-model="chartPeriod" @change="updateChart">
        <option value="day">Today</option>
        <option value="week">This Week</option>
        <option value="month">This Month</option>
      </select>
    </div>
    <canvas id="weatherChart" ref="weatherChart"></canvas>
  </div>

  <table id="weather-table" border="1" :data-sort-order="sortOrder">
    <thead>
      <tr>
        <th @click="sortTable(0)">
          Plant Name <span class="sort-icon" v-text="getSortIcon(0)"></span>
        </th>
        <th @click="sortTable(1)">
          Location <span class="sort-icon" v-text="getSortIcon(1)"></span>
        </th>
        <th @click="sortTable(2)">
          Temperature <span class="sort-icon" v-text="getSortIcon(2)"></span>
        </th>
        <th @click="sortTable(3)">
          Weather <span class="sort-icon" v-text="getSortIcon(3)"></span>
        </th>
        <th @click="sortTable(4)">
          Humidity <span class="sort-icon" v-text="getSortIcon(4)"></span>
        </th>
        <th @click="sortTable(5)">
          Last Update Time
          <span class="sort-icon" v-text="getSortIcon(5)"></span>
        </th>
      </tr>
    </thead>
    <tbody>
      <tr
        v-for="(item, index) in weatherData"
        :key="index"
        :class="{ 'offline-row': item.status === 'Offline' }"
      >
        <td v-text="item.plant_name"></td>
        <td v-text="item.location"></td>
        <td v-text="item.temperature"></td>
        <td v-text="item.weather"></td>
        <td v-text="item.humidity"></td>
        <td v-text="item.last_update_time"></td>
      </tr>
    </tbody>
  </table>
</div>

<!-- Load Chart.js before our Vue app -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const plantId = "{{ plant_id }}"; // Pass the plant ID from the server-side
    const cacheKey = `weather_${plantId}`;
    const cacheExpiration = 15 * 60 * 1000; // Cache expiration time in milliseconds (e.g., 15 minutes)

    const WeatherApp = {
      delimiters: ["${", "}"], // Use different delimiters to avoid conflict with Jinja2
      data() {
        return {
          weatherData: [],
          sortOrder: "asc",
          currentSortColumn: 0,
          isLoading: false,
          chartMetric: "temperature",
          chartPeriod: "day",
          weatherChart: null,
        };
      },
      mounted() {
        this.checkCacheAndFetchData();
      },
      methods: {
        checkCacheAndFetchData() {
          const cachedData = localStorage.getItem(cacheKey);

          if (cachedData) {
            const parsedCache = JSON.parse(cachedData);
            const isCacheValid =
              Date.now() - parsedCache.timestamp < cacheExpiration;

            if (isCacheValid) {
              this.weatherData = parsedCache.data;
              this.initializeChart();
            } else {
              this.fetchWeatherData(); // Cache expired, fetch new data
            }
          } else {
            this.fetchWeatherData(); // No cache, fetch data
          }
        },
        fetchWeatherData() {
          this.isLoading = true;

          fetch(`/api/weather?plantId=${plantId}`)
            .then((response) => {
              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
              }
              return response.json();
            })
            .then((data) => {
              // Cache the data with a timestamp
              const cacheData = {
                timestamp: Date.now(),
                data: data,
              };
              localStorage.setItem(cacheKey, JSON.stringify(cacheData));
              this.weatherData = data;
              this.initializeChart();
            })
            .catch((error) =>
              console.error("Error fetching weather data:", error)
            )
            .finally(() => {
              this.isLoading = false;
            });
        },
        initializeChart() {
          try {
            if (this.weatherChart) {
              this.weatherChart.destroy();
            }

            // Process weather data using our utility function
            let chartData;

            if (window.EnergyCharts) {
              // Use our utility function to process the data
              const processed = window.EnergyCharts.processWeatherData(
                this.weatherData,
                this.chartMetric,
                this.chartPeriod
              );

              chartData = {
                labels: processed.labels,
                datasets: [
                  window.EnergyCharts.createDataset(
                    this.getChartTitle(),
                    processed.values,
                    this.chartMetric === "temperature"
                      ? "tertiary"
                      : "secondary",
                    {
                      tension: 0.3,
                      pointRadius: 3,
                      pointHoverRadius: 5,
                      unit:
                        this.chartMetric === "temperature"
                          ? "°C"
                          : this.chartMetric === "humidity"
                          ? "%"
                          : "",
                    }
                  ),
                ],
              };
            } else {
              // Fallback to manual processing
              chartData = this.prepareChartData();

              // Try to load the energy charts util dynamically
              const script = document.createElement("script");
              script.src = "/static/js/energy_chart.js";
              document.head.appendChild(script);
              script.onload = () => {
                this.updateChart();
              };
            }

            const ctx = this.$refs.weatherChart.getContext("2d");

            // Use Chart.js from the global scope
            this.weatherChart = new Chart(ctx, {
              type: "line",
              data: chartData,
              options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                  tooltip: {
                    mode: "index",
                    intersect: false,
                    callbacks: {
                      label: function (context) {
                        let label = context.dataset.label || "";
                        if (label) {
                          label += ": ";
                        }
                        if (context.parsed.y !== null) {
                          label += context.parsed.y;
                          if (context.dataset.unit) {
                            label += context.dataset.unit;
                          }
                        }
                        return label;
                      },
                    },
                  },
                  legend: {
                    position: "top",
                    labels: {
                      usePointStyle: true,
                      padding: 20,
                    },
                  },
                  title: {
                    display: true,
                    text: this.getChartTitle(),
                  },
                },
                scales: {
                  y: {
                    beginAtZero: this.chartMetric === "humidity",
                    title: {
                      display: true,
                      text: this.getAxisTitle(),
                    },
                  },
                  x: {
                    title: {
                      display: true,
                      text: "Time",
                    },
                  },
                },
              },
            });
          } catch (error) {
            console.error("Error initializing weather chart:", error);
          }
        },
        prepareChartData() {
          let labels = [];
          let data = [];
          let backgroundColor = "rgba(75, 192, 192, 0.2)";
          let borderColor = "rgba(75, 192, 192, 1)";
          let unit = "";

          if (this.chartMetric === "temperature") {
            backgroundColor = "rgba(255, 99, 132, 0.2)";
            borderColor = "rgba(255, 99, 132, 1)";
            unit = "°C";
          } else if (this.chartMetric === "humidity") {
            backgroundColor = "rgba(54, 162, 235, 0.2)";
            borderColor = "rgba(54, 162, 235, 1)";
            unit = "%";
          }

          this.weatherData.forEach((item) => {
            const value = parseFloat(
              String(item[this.chartMetric]).replace(/[^\d.-]/g, "")
            );
            if (!isNaN(value)) {
              labels.push(item.last_update_time);
              data.push(value);
            }
          });

          return {
            labels: labels,
            datasets: [
              {
                label: this.getChartTitle(),
                data: data,
                backgroundColor: backgroundColor,
                borderColor: borderColor,
                borderWidth: 2,
                tension: 0.3,
                pointRadius: 3,
                pointHoverRadius: 5,
                unit: unit,
              },
            ],
          };
        },
        getChartTitle() {
          let title = "";
          switch (this.chartMetric) {
            case "temperature":
              title = "Temperature Trends";
              break;
            case "humidity":
              title = "Humidity Levels";
              break;
            case "weather":
              title = "Weather Conditions";
              break;
          }
          return title + " - " + this.getPeriodText();
        },
        getAxisTitle() {
          switch (this.chartMetric) {
            case "temperature":
              return "Temperature (°C)";
            case "humidity":
              return "Humidity (%)";
            case "weather":
              return "Condition";
            default:
              return "";
          }
        },
        getPeriodText() {
          switch (this.chartPeriod) {
            case "day":
              return "Today";
            case "week":
              return "This Week";
            case "month":
              return "This Month";
            default:
              return "";
          }
        },
        updateChart() {
          this.initializeChart();
        },
        sortTable(columnIndex) {
          if (this.currentSortColumn === columnIndex) {
            this.sortOrder = this.sortOrder === "asc" ? "desc" : "asc";
          } else {
            this.currentSortColumn = columnIndex;
            this.sortOrder = "asc";
          }

          const direction = this.sortOrder === "asc" ? 1 : -1;

          this.weatherData.sort((a, b) => {
            const valueA = Object.values(a)[columnIndex];
            const valueB = Object.values(b)[columnIndex];

            if (!isNaN(valueA) && !isNaN(valueB)) {
              return direction * (parseFloat(valueA) - parseFloat(valueB));
            }

            return direction * String(valueA).localeCompare(String(valueB));
          });
        },
        getSortIcon(columnIndex) {
          if (this.currentSortColumn !== columnIndex) {
            return "▲";
          }
          return this.sortOrder === "asc" ? "▲" : "▼";
        },
        exportToExcel() {
          const headers = [
            "Plant Name",
            "Location",
            "Temperature",
            "Weather",
            "Humidity",
            "Last Update Time",
          ];
          let csvContent = "\uFEFF";

          csvContent += headers.map((header) => `"${header}"`).join(",") + "\n";

          this.weatherData.forEach((item) => {
            const row = [
              item.plant_name,
              item.location,
              item.temperature,
              item.weather,
              item.humidity,
              item.last_update_time,
            ]
              .map((cell) => `"${cell?.toString().replace(/"/g, '""')}"`)
              .join(",");

            csvContent += row + "\n";
          });

          const blob = new Blob([csvContent], {
            type: "text/csv;charset=utf-8;",
          });
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = `weather_${plantId}.csv`;
          link.style.display = "none";
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        },
      },
      beforeUnmount() {
        if (this.weatherChart) {
          this.weatherChart.destroy();
        }
      },
    };

    // Create the Vue app after the DOM is fully loaded
    const app = Vue.createApp(WeatherApp).mount("#weather-app");
  });
</script>

<style>
  .weather-chart-container {
    margin: 20px 0;
    padding: 15px;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    height: 400px;
  }

  .chart-controls {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
  }

  .chart-controls select {
    padding: 8px;
    border-radius: 4px;
    border: 1px solid #ddd;
    background-color: white;
  }

  /* Add missing styles for v-cloak */
  [v-cloak] {
    display: none;
  }

  /* Add missing style for the spinner */
  .spinner {
    width: 40px;
    height: 40px;
    border: 4px solid rgba(0, 0, 0, 0.1);
    border-left-color: #09f;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 20px auto;
  }

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  /* Add style for offline rows */
  .offline-row {
    background-color: rgba(248, 113, 113, 0.2);
  }
</style>
{% endblock %} {% block head_scripts %}
<!-- Make sure Vue.js is loaded first -->
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
{% endblock %}
