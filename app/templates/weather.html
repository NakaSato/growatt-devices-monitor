{% extends "base.html" %} {% block title %}Weather Status - Growatt API{%
endblock %} {% block content %}
<div id="weather-app" v-cloak>
  <h1>Weather Status for Plant: {{ plant_name }}</h1>

  <!-- Loading spinner -->
  <div
    :class="{'spinner': true}"
    :style="{ display: isLoading ? 'block' : 'none' }"
  ></div>

  <!-- Export Button -->
  <button class="btn btn-primary" @click="exportToExcel">
    Export to Excel
  </button>

  <!-- Weather Chart Visualization -->
  <div class="weather-chart-container">
    <h2>Weather Trends</h2>
    <div class="chart-controls">
      <select v-model="chartMetric" @change="updateChart">
        <option value="temperature">Temperature</option>
        <option value="humidity">Humidity</option>
        <option value="weather">Weather Conditions</option>
      </select>
      <select v-model="chartPeriod" @change="updateChart">
        <option value="day">Today</option>
        <option value="week">This Week</option>
        <option value="month">This Month</option>
      </select>
    </div>
    <canvas id="weatherChart" ref="weatherChart"></canvas>
  </div>

  <table id="weather-table" border="1" :data-sort-order="sortOrder">
    <thead>
      <tr>
        <th @click="sortTable(0)">
          Plant Name <span class="sort-icon" v-text="getSortIcon(0)"></span>
        </th>
        <th @click="sortTable(1)">
          Location <span class="sort-icon" v-text="getSortIcon(1)"></span>
        </th>
        <th @click="sortTable(2)">
          Temperature <span class="sort-icon" v-text="getSortIcon(2)"></span>
        </th>
        <th @click="sortTable(3)">
          Weather <span class="sort-icon" v-text="getSortIcon(3)"></span>
        </th>
        <th @click="sortTable(4)">
          Humidity <span class="sort-icon" v-text="getSortIcon(4)"></span>
        </th>
        <th @click="sortTable(5)">
          Last Update Time
          <span class="sort-icon" v-text="getSortIcon(5)"></span>
        </th>
      </tr>
    </thead>
    <tbody>
      <tr
        v-for="(item, index) in weatherData"
        :key="index"
        :class="{ 'offline-row': item.status === 'Offline' }"
      >
        <td v-text="item.plant_name"></td>
        <td v-text="item.location"></td>
        <td v-text="item.temperature"></td>
        <td v-text="item.weather"></td>
        <td v-text="item.humidity"></td>
        <td v-text="item.last_update_time"></td>
      </tr>
    </tbody>
  </table>
</div>

<!-- Load Chart.js before our Vue app -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const plantId = "{{ plant_id }}"; // Pass the plant ID from the server-side
    const cacheKey = `weather_${plantId}`;
    const cacheExpiration = 15 * 60 * 1000; // Cache expiration time in milliseconds (e.g., 15 minutes)

    const WeatherApp = {
      delimiters: ["${", "}"], // Use different delimiters to avoid conflict with Jinja2
      data() {
        return {
          weatherData: [],
          sortOrder: "asc",
          currentSortColumn: 0,
          isLoading: false,
          chartMetric: "temperature",
          chartPeriod: "day",
          weatherChart: null,
        };
      },
      mounted() {
        this.checkCacheAndFetchData();
      },
      methods: {
        checkCacheAndFetchData() {
          const cachedData = localStorage.getItem(cacheKey);

          if (cachedData) {
            const parsedCache = JSON.parse(cachedData);
            const isCacheValid =
              Date.now() - parsedCache.timestamp < cacheExpiration;

            if (isCacheValid) {
              this.weatherData = parsedCache.data;
              this.initializeChart();
              return;
            }
          }

          this.fetchWeatherData(); // Cache expired or no cache, fetch new data
        },

        fetchWeatherData() {
          this.isLoading = true;

          fetch(`/api/weather?plantId=${plantId}`)
            .then((response) => {
              if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
              }
              return response.json();
            })
            .then((data) => {
              this.weatherData = Array.isArray(data) ? data : [];

              // Cache the data with timestamp
              const cacheData = {
                timestamp: Date.now(),
                data: this.weatherData,
              };
              localStorage.setItem(cacheKey, JSON.stringify(cacheData));

              this.initializeChart();
            })
            .catch((error) => {
              console.error("Error fetching weather data:", error);
              alert(`Failed to load weather data: ${error.message}`);
            })
            .finally(() => {
              this.isLoading = false;
            });
        },

        initializeChart() {
          if (!this.weatherData.length) return;

          try {
            const chartData = this.processChartData();
            const ctx = this.$refs.weatherChart.getContext("2d");

            // Destroy previous chart instance if it exists
            if (this.weatherChart) {
              this.weatherChart.destroy();
            }

            this.weatherChart = new Chart(ctx, {
              type: "line",
              data: {
                labels: chartData.labels,
                datasets: [
                  {
                    label: this.getMetricLabel(),
                    data: chartData.values,
                    backgroundColor: "rgba(75, 192, 192, 0.2)",
                    borderColor: "rgba(75, 192, 192, 1)",
                    borderWidth: 2,
                    tension: 0.3,
                    pointRadius: 3,
                  },
                ],
              },
              options: {
                responsive: true,
                plugins: {
                  title: {
                    display: true,
                    text: `Weather ${this.getMetricLabel()} - ${this.getChartPeriodLabel()}`,
                  },
                  tooltip: {
                    callbacks: {
                      label: (context) => {
                        let label = context.dataset.label || "";
                        if (label) {
                          label += ": ";
                        }
                        if (context.parsed.y !== null) {
                          label += this.getMetricValueWithUnit(
                            context.parsed.y
                          );
                        }
                        return label;
                      },
                    },
                  },
                },
                scales: {
                  y: {
                    beginAtZero: this.chartMetric === "weather",
                    title: {
                      display: true,
                      text: this.getMetricLabel(),
                    },
                  },
                },
              },
            });
          } catch (error) {
            console.error("Error initializing chart:", error);
          }
        },

        updateChart() {
          this.initializeChart();
        },

        processChartData() {
          // Extract and process data for chart based on selected metric and period
          let data = this.weatherData;
          let labels = [];
          let values = [];

          // Implement the data processing logic based on chartMetric and chartPeriod
          // This is a simplified example
          data.forEach((item) => {
            let value = null;

            switch (this.chartMetric) {
              case "temperature":
                value = this.extractNumericValue(item.temperature);
                break;
              case "humidity":
                value = this.extractNumericValue(item.humidity);
                break;
              case "weather":
                // Map weather conditions to numeric values for visualization
                value = this.weatherConditionToValue(item.weather);
                break;
            }

            if (value !== null) {
              labels.push(new Date(item.last_update_time).toLocaleTimeString());
              values.push(value);
            }
          });

          return { labels, values };
        },

        extractNumericValue(str) {
          if (!str) return null;
          const matches = str.toString().match(/[-+]?\d*\.?\d+/);
          return matches ? parseFloat(matches[0]) : null;
        },

        weatherConditionToValue(condition) {
          if (!condition) return 5; // Default/unknown

          const conditions = {
            Clear: 10,
            Sunny: 9,
            "Partly Cloudy": 7,
            Cloudy: 5,
            Overcast: 4,
            Rainy: 3,
            Rain: 3,
            Stormy: 1,
            Snow: 2,
          };

          // Try to match condition to known values
          for (const [key, value] of Object.entries(conditions)) {
            if (condition.toLowerCase().includes(key.toLowerCase())) {
              return value;
            }
          }

          return 5; // Default value
        },

        getMetricLabel() {
          switch (this.chartMetric) {
            case "temperature":
              return "Temperature";
            case "humidity":
              return "Humidity";
            case "weather":
              return "Weather Conditions";
            default:
              return this.chartMetric;
          }
        },

        getChartPeriodLabel() {
          switch (this.chartPeriod) {
            case "day":
              return "Today";
            case "week":
              return "This Week";
            case "month":
              return "This Month";
            default:
              return this.chartPeriod;
          }
        },

        getMetricValueWithUnit(value) {
          switch (this.chartMetric) {
            case "temperature":
              return `${value}°C`;
            case "humidity":
              return `${value}%`;
            case "weather":
              return `${value} (${this.valueToWeatherCondition(value)})`;
            default:
              return value;
          }
        },

        valueToWeatherCondition(value) {
          if (value >= 9) return "Sunny/Clear";
          if (value >= 7) return "Partly Cloudy";
          if (value >= 5) return "Cloudy";
          if (value >= 3) return "Rainy";
          if (value >= 2) return "Snow";
          return "Stormy";
        },

        sortTable(columnIndex) {
          if (this.currentSortColumn === columnIndex) {
            // Toggle sort order if clicking on the same column
            this.sortOrder = this.sortOrder === "asc" ? "desc" : "asc";
          } else {
            // Default to ascending order for a new column
            this.sortOrder = "asc";
            this.currentSortColumn = columnIndex;
          }

          // Sort the weather data array
          this.weatherData.sort((a, b) => {
            const keys = [
              "plant_name",
              "location",
              "temperature",
              "weather",
              "humidity",
              "last_update_time",
            ];
            const key = keys[columnIndex];

            let valueA = a[key] || "";
            let valueB = b[key] || "";

            // Handle numeric sorting for temperature and humidity
            if (columnIndex === 2 || columnIndex === 4) {
              valueA = this.extractNumericValue(valueA) || 0;
              valueB = this.extractNumericValue(valueB) || 0;
            }

            // Handle date sorting for last update time
            if (columnIndex === 5) {
              valueA = new Date(valueA).getTime();
              valueB = new Date(valueB).getTime();
            }

            // Apply sort direction
            return this.sortOrder === "asc"
              ? valueA > valueB
                ? 1
                : -1
              : valueA < valueB
              ? 1
              : -1;
          });
        },

        getSortIcon(columnIndex) {
          if (this.currentSortColumn !== columnIndex) return "▲";
          return this.sortOrder === "asc" ? "▲" : "▼";
        },

        exportToExcel() {
          if (!this.weatherData.length) {
            alert("No data to export!");
            return;
          }

          try {
            // Create CSV content
            let csvContent = "data:text/csv;charset=utf-8,";

            // Add headers
            csvContent +=
              "Plant Name,Location,Temperature,Weather,Humidity,Last Update Time\n";

            // Add data rows
            this.weatherData.forEach((item) => {
              const row = [
                item.plant_name || "",
                item.location || "",
                item.temperature || "",
                item.weather || "",
                item.humidity || "",
                item.last_update_time || "",
              ]
                .map((cell) => `"${cell}"`)
                .join(",");

              csvContent += row + "\n";
            });

            // Create download link
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute(
              "download",
              `weather_data_${plantId}_${new Date()
                .toISOString()
                .slice(0, 10)}.csv`
            );
            document.body.appendChild(link);

            // Trigger download and clean up
            link.click();
            document.body.removeChild(link);
          } catch (error) {
            console.error("Error exporting to Excel:", error);
            alert("Failed to export data. See console for details.");
          }
        },
      },
    };

    const app = Vue.createApp(WeatherApp).mount("#weather-app");
  });
</script>
{% endblock %}
