<!-- Dashboard metrics component -->
<div class="metrics-container">
  <div class="metrics-row">
    <!-- Total Energy Yield Today Card -->
    <div class="metric-card">
      <div class="card-header">
        <h3 class="card-title">Total Energy Yield Today</h3>
      </div>
      <div>
        <p class="metric-value">45.23 kWh</p>
        <p class="metric-comparison">+20.1% from yesterday</p>
        <div class="metric-trend">
          <span class="trend-icon">‚Üë</span>
          <span>+20.1%</span>
        </div>
      </div>
    </div>

    <!-- Total Devices Card -->
    <div class="metric-card">
      <div class="card-header">
        <h3 class="card-title">Total Devices</h3>
        <span class="card-icon">üîå</span>
      </div>
      <div>
        <p class="metric-value">2,350</p>
        <p class="metric-comparison">
          <span class="online-status">Online: 2,150</span> |
          <span class="offline-status">Offline: 200</span>
        </p>
      </div>
    </div>

    <!-- Total Faults Card -->
    <div class="metric-card">
      <div class="card-header">
        <h3 class="card-title">Total Faults</h3>
        <span class="card-icon">‚ö†Ô∏è</span>
      </div>
      <div>
        <p class="metric-value">24</p>
        <p class="metric-comparison">-19% from yesterday</p>
        <div class="fault-breakdown">
          <div class="fault-item">
            <span class="fault-icon">üö´</span>
            <span class="fault-category">Code Errors: <strong>15</strong></span>
          </div>
          <div class="fault-item">
            <span class="fault-icon">‚öôÔ∏è</span>
            <span class="fault-category"
              >Device Faults: <strong>9</strong></span
            >
          </div>
        </div>
      </div>
    </div>

    <!-- System Performance Card -->
    <div class="metric-card">
      <div class="card-header">
        <h3 class="card-title">System Performance</h3>
        <span class="card-icon">üìà</span>
      </div>
      <div>
        <p class="metric-value">98.6%</p>
        <p class="metric-comparison">+1.4% from last week</p>
        <div class="metric-trend">
          <span class="trend-icon">‚Üë</span>
          <span>+1.4%</span>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Energy Production Chart -->
<div
  class="chart-container"
  id="energy-production-chart"
  x-data="{ activePeriod: 'day', summaryText: 'Loading...', periodComparison: '', filters: [] }"
>
  <div class="chart-card">
    <div class="card-header">
      <h3 class="card-title">Energy Yield Overview</h3>
      <div class="chart-controls">
        <div class="chart-period-info">
          <span class="period-summary" x-text="summaryText"></span>
          <span class="period-comparison" x-text="periodComparison"></span>
        </div>
        <select
          class="chart-period-selector"
          x-model="activePeriod"
          @change="$dispatch('period-change', activePeriod)"
        >
          <option value="day">Today</option>
          <option value="week">This Week</option>
          <option value="month">This Month</option>
          <option value="year">This Year</option>
        </select>
      </div>
    </div>
    <div class="chart-wrapper">
      <canvas id="energyProductionChart"></canvas>
    </div>
    <div class="chart-legend">
      <div class="legend-item">
        <span
          class="legend-color"
          style="background-color: rgba(16, 185, 129, 0.7)"
        ></span>
        <span class="legend-label">Current Period</span>
      </div>
      <div class="legend-item">
        <span
          class="legend-color"
          style="background-color: rgba(209, 213, 219, 0.5)"
        ></span>
        <span class="legend-label">Previous Period</span>
      </div>
    </div>
  </div>
</div>

<!-- Energy Prediction Chart -->
<div
  class="chart-container prediction-chart-container"
  id="energy-prediction-chart"
  x-data="{ days: 7, totalPrediction: '0.00', isLoading: true }"
>
  <div class="chart-card">
    <div class="card-header">
      <h3 class="card-title">Energy Yield Prediction</h3>
      <div class="chart-controls">
        <div class="chart-period-info">
          <span class="period-summary">
            Predicted next <span x-text="days"></span> days:
            <strong
              x-text="isLoading ? 'Loading...' : `${totalPrediction} kWh`"
            ></strong>
          </span>
          <span class="period-comparison"
            >Based on historical data analysis</span
          >
        </div>
        <select
          class="prediction-period-selector"
          x-model="days"
          @change="$dispatch('fetch-data', days)"
        >
          <option value="7">Next 7 Days</option>
          <option value="14">Next 14 Days</option>
          <option value="30">Next 30 Days</option>
        </select>
      </div>
    </div>
    <div class="chart-wrapper">
      <canvas id="energyPredictionChart"></canvas>
    </div>
    <div class="chart-legend">
      <div class="legend-item">
        <span
          class="legend-color"
          style="background-color: rgba(79, 70, 229, 0.7)"
        ></span>
        <span class="legend-label">Predicted Energy</span>
      </div>
      <div class="legend-item">
        <span
          class="legend-color"
          style="background-color: rgba(16, 185, 129, 0.7)"
        ></span>
        <span class="legend-label">Historical Energy</span>
      </div>
      <div class="legend-item">
        <span
          class="legend-color"
          style="background-color: rgba(209, 213, 219, 0.5)"
        ></span>
        <span class="legend-label">Confidence Interval</span>
      </div>
    </div>
  </div>
</div>

<!-- Power Distribution Chart -->
<div
  class="chart-container additional-charts"
  id="power-distribution-chart"
  x-data="{ selectedSegment: null }"
>
  <div class="chart-card">
    <div class="card-header">
      <h3 class="card-title">Power Distribution</h3>
      <div class="chart-controls" x-show="selectedSegment">
        <div class="selected-segment-info">
          <span>Selected: <strong x-text="selectedSegment"></strong></span>
          <button
            class="btn-close"
            @click="$dispatch('deselect-segment'); selectedSegment = null"
          >
            √ó
          </button>
        </div>
      </div>
    </div>
    <div id="powerDistributionChart" style="height: 300px"></div>
  </div>
</div>

<!-- Required libraries - Only loading what this specific component needs -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
<script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>

<script>
  function initEnergyProductionChart() {
    // Get the context
    const ctx = document
      .getElementById("energyProductionChart")
      ?.getContext("2d");
    if (!ctx) return null;

    // Generate realistic data using our utility if available
    let labels = [];
    let currentPeriodData = [];
    let previousPeriodData = [];

    // Use the period data from Alpine
    const productionEl = document.getElementById("energy-production-chart");
    const period = productionEl?._x_dataStack?.[0]?.activePeriod || "day";

    // Generate data using our utility if available
    if (window.EnergyDataUtils) {
      const today = new Date();
      const data = window.EnergyDataUtils.generateEnergyData(period, 10, today);

      // Get current period data
      labels = data.labels;
      currentPeriodData = data.datasets.production;

      // Generate previous period data (slightly different)
      let prevDate;
      switch (period) {
        case "day":
          prevDate = new Date();
          prevDate.setDate(prevDate.getDate() - 1);
          break;
        case "week":
          prevDate = new Date();
          prevDate.setDate(prevDate.getDate() - 7);
          break;
        case "month":
          prevDate = new Date();
          prevDate.setMonth(prevDate.getMonth() - 1);
          break;
        case "year":
          prevDate = new Date();
          prevDate.setFullYear(prevDate.getFullYear() - 1);
          break;
      }

      const prevData = window.EnergyDataUtils.generateEnergyData(
        period,
        9.5,
        prevDate
      );
      previousPeriodData = prevData.datasets.production;

      // Update summary text
      const totalProduction = data.totals.production;
      if (productionEl?._x_dataStack?.[0]) {
        productionEl._x_dataStack[0].summaryText = `Total ${period}: <strong>${totalProduction} kWh</strong>`;

        const prevTotal = prevData.totals.production;
        const diffPercent = (
          ((totalProduction - prevTotal) / prevTotal) *
          100
        ).toFixed(1);
        productionEl._x_dataStack[0].periodComparison = `${
          diffPercent > 0 ? "+" : ""
        }${diffPercent}% from previous ${period}`;
      }
    } else {
      // Fallback if utility not available
      switch (period) {
        case "day":
          labels = Array.from({ length: 24 }, (_, i) => `${i}:00`);
          break;
        case "week":
          labels = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
          break;
        case "month":
          labels = Array.from({ length: 30 }, (_, i) => `${i + 1}`);
          break;
        case "year":
          labels = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec",
          ];
          break;
      }

      currentPeriodData = labels.map(() => Math.random() * 10 + 5);
      previousPeriodData = labels.map(() => Math.random() * 8 + 5);
    }

    // Create the chart
    return new Chart(ctx, {
      type: "bar",
      data: {
        labels: labels,
        datasets: [
          {
            label: "Current Period",
            data: currentPeriodData,
            backgroundColor: "rgba(16, 185, 129, 0.7)",
            borderColor: "rgba(16, 185, 129, 1)",
            borderWidth: 1,
            borderRadius: 4,
            barPercentage: 0.6,
          },
          {
            label: "Previous Period",
            data: previousPeriodData,
            backgroundColor: "rgba(209, 213, 219, 0.5)",
            borderColor: "rgba(209, 213, 219, 0.8)",
            borderWidth: 1,
            borderRadius: 4,
            barPercentage: 0.6,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: "bottom",
            labels: {
              usePointStyle: true,
              padding: 20,
            },
          },
          tooltip: {
            mode: "index",
            intersect: false,
            callbacks: {
              label: function (context) {
                let label = context.dataset.label || "";
                if (context.parsed.y !== null) {
                  label += `: ${context.parsed.y.toFixed(2)} kWh`;
                }
                return label;
              },
            },
          },
        },
        scales: {
          y: {
            beginAtZero: true,
            title: {
              display: true,
              text: "Energy Production (kWh)",
            },
            grid: {
              color: "rgba(243, 244, 246, 0.7)",
            },
          },
          x: {
            grid: {
              display: false,
            },
          },
        },
      },
    });
  }

  function initPredictionChart() {
    // Get the context
    const ctx = document
      .getElementById("energyPredictionChart")
      ?.getContext("2d");
    if (!ctx) return null;

    // Use the period data from Alpine
    const predictionEl = document.getElementById("energy-prediction-chart");
    const days = predictionEl?._x_dataStack?.[0]?.days || 7;

    // Generate prediction data
    const labels = Array.from({ length: days }, (_, i) => {
      const date = new Date();
      date.setDate(date.getDate() + i);
      return date.toLocaleDateString("en-US", {
        month: "short",
        day: "numeric",
      });
    });

    // Generate realistic data using seasonality
    let predictionData = [];
    let historicalData = [];
    let confidenceLow = [];
    let confidenceHigh = [];

    // Use our utility if available
    if (window.EnergyDataUtils) {
      const today = new Date();
      const month = today.getMonth();
      const seasonalFactor = window.EnergyDataUtils.getSeasonalFactor(month);

      // Generate daily predictions
      predictionData = labels.map((_, index) => {
        const dayFactor = 1 + Math.sin((index / days) * Math.PI) * 0.2;
        const randomFactor = 0.9 + Math.random() * 0.2;
        const weatherFactor = Math.random() > 0.7 ? 0.7 : 1;

        return +(
          seasonalFactor *
          10 *
          dayFactor *
          randomFactor *
          weatherFactor
        ).toFixed(2);
      });

      // Generate historical data (slightly different)
      historicalData = labels.map((_, index) => {
        if (index < 2) {
          const dayFactor = 1 + Math.sin((index / days) * Math.PI) * 0.2;
          const randomFactor = 0.9 + Math.random() * 0.2;
          return +(seasonalFactor * 10 * dayFactor * randomFactor).toFixed(2);
        }
        return null; // No historical data for future days
      });

      // Generate confidence intervals
      confidenceLow = predictionData.map((val) => val * 0.8);
      confidenceHigh = predictionData.map((val) => val * 1.2);

      // Update summary in Alpine
      if (predictionEl?._x_dataStack?.[0]) {
        const total = predictionData
          .reduce((sum, val) => sum + val, 0)
          .toFixed(2);
        predictionEl._x_dataStack[0].totalPrediction = total;
        predictionEl._x_dataStack[0].isLoading = false;
      }
    } else {
      // Fallback
      predictionData = labels.map(() => Math.random() * 10 + 5);
      historicalData = labels.map((_, i) =>
        i < 2 ? Math.random() * 10 + 5 : null
      );
      confidenceLow = predictionData.map((val) => val * 0.8);
      confidenceHigh = predictionData.map((val) => val * 1.2);
    }

    // Create the chart
    return new Chart(ctx, {
      type: "line",
      data: {
        labels: labels,
        datasets: [
          {
            label: "Predicted Energy",
            data: predictionData,
            borderColor: "rgba(79, 70, 229, 1)",
            backgroundColor: "rgba(79, 70, 229, 0.1)",
            borderWidth: 2,
            tension: 0.3,
            fill: false,
          },
          {
            label: "Historical Energy",
            data: historicalData,
            borderColor: "rgba(16, 185, 129, 1)",
            backgroundColor: "rgba(16, 185, 129, 0.5)",
            borderWidth: 2,
            pointRadius: 4,
            tension: 0,
            fill: false,
          },
          {
            label: "Confidence Interval",
            data: confidenceLow,
            borderColor: "rgba(209, 213, 219, 0)",
            backgroundColor: "rgba(209, 213, 219, 0.3)",
            borderWidth: 0,
            tension: 0.3,
            fill: "+1", // Fill to the next dataset
            pointRadius: 0,
          },
          {
            label: "Confidence Interval",
            data: confidenceHigh,
            borderColor: "rgba(209, 213, 219, 0)",
            backgroundColor: "rgba(209, 213, 219, 0.3)",
            tension: 0.3,
            fill: false,
            pointRadius: 0,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: "bottom",
            labels: {
              filter: function (item) {
                // Hide confidence interval from legend
                return !item.text.includes("Confidence");
              },
              usePointStyle: true,
              padding: 20,
            },
          },
          tooltip: {
            mode: "index",
            intersect: false,
            callbacks: {
              label: function (context) {
                // Only show tooltip for non-confidence interval datasets
                if (context.dataset.label.includes("Confidence")) {
                  return null;
                }
                let label = context.dataset.label || "";
                if (label) {
                  label += ": ";
                }
                if (context.parsed.y !== null) {
                  label += context.parsed.y.toFixed(2) + " kWh";
                }
                return label;
              },
            },
          },
        },
        scales: {
          y: {
            beginAtZero: true,
            title: {
              display: true,
              text: "Energy (kWh)",
            },
          },
          x: {
            grid: {
              display: false,
            },
          },
        },
      },
    });
  }

  function initPowerDistributionChart() {
    if (typeof echarts === "undefined") {
      console.error("ECharts is not loaded");
      return null;
    }

    const chartElement = document.getElementById("powerDistributionChart");
    if (!chartElement) {
      console.error("Power distribution chart element not found");
      return null;
    }

    const chart = echarts.init(chartElement);

    // Generate data with our utility if available
    let chartData;
    if (window.EnergyDataUtils) {
      const data = window.EnergyDataUtils.generateEnergyData(
        "day",
        10,
        new Date()
      );
      chartData = [
        {
          value: parseFloat(data.totals.selfConsumption),
          name: "Self-consumption",
        },
        { value: parseFloat(data.totals.gridExport), name: "Grid Export" },
        { value: parseFloat(data.totals.gridImport), name: "Grid Import" },
      ];
    } else {
      chartData = [
        { value: 32.5, name: "Self-consumption" },
        { value: 12.8, name: "Grid Export" },
        { value: 4.7, name: "Grid Import" },
      ];
    }

    chart.setOption({
      tooltip: {
        trigger: "item",
        formatter: "{a} <br/>{b}: {c} kWh ({d}%)",
      },
      legend: {
        data: chartData.map((item) => item.name),
        bottom: 10,
        selectedMode: "single",
      },
      series: [
        {
          name: "Power Distribution",
          type: "pie",
          radius: ["50%", "70%"],
          avoidLabelOverlap: false,
          itemStyle: {
            borderRadius: 10,
            borderColor: "#fff",
            borderWidth: 2,
          },
          label: {
            show: false,
            position: "center",
          },
          emphasis: {
            label: {
              show: true,
              fontSize: "18",
              fontWeight: "bold",
            },
            itemStyle: {
              shadowBlur: 10,
              shadowOffsetX: 0,
              shadowColor: "rgba(0, 0, 0, 0.5)",
            },
          },
          labelLine: {
            show: false,
          },
          data: chartData,
        },
      ],
    });

    // Add click handler
    chart.on("click", function (params) {
      if (params.componentType === "series") {
        const name = params.name;
        const el = document.getElementById("power-distribution-chart");

        if (!el || !el._x_dataStack || !el._x_dataStack[0]) {
          console.warn("Power distribution chart Alpine data not found");
          return;
        }

        if (el._x_dataStack[0].selectedSegment === name) {
          el._x_dataStack[0].selectedSegment = null;
          chart.dispatchAction({
            type: "downplay",
            seriesIndex: 0,
          });
        } else {
          el._x_dataStack[0].selectedSegment = name;
          chart.dispatchAction({
            type: "highlight",
            dataIndex: params.dataIndex,
          });
        }
      }
    });

    return chart;
  }

  // Make sure the charts are initialized after DOM is ready and our utilities are loaded
  document.addEventListener("DOMContentLoaded", function () {
    // Initialize energy-chart.js script dynamically if not already loaded
    if (!window.EnergyDataUtils) {
      const script = document.createElement("script");
      script.src = "/static/js/energy_chart.js";
      script.onload = function () {
        // Initialize all charts once utilities are loaded
        initAllCharts();
      };
      document.head.appendChild(script);
    } else {
      // Initialize immediately if utilities already exist
      initAllCharts();
    }

    function initAllCharts() {
      try {
        // Register Chart.js plugins
        if (
          typeof Chart !== "undefined" &&
          typeof ChartDataLabels !== "undefined"
        ) {
          Chart.register(ChartDataLabels);
        } else {
          console.warn("Chart.js or ChartDataLabels not available");
        }

        // Make sure chart elements exist before initialization
        const energyProductionChartElement = document.getElementById(
          "energy-production-chart"
        );
        const energyPredictionChartElement = document.getElementById(
          "energy-prediction-chart"
        );
        const powerDistributionChartElement = document.getElementById(
          "power-distribution-chart"
        );

        let energyProductionChart = null;
        let predictionChart = null;
        let powerDistributionChart = null;

        // Energy Production Chart initialization
        if (
          energyProductionChartElement &&
          document.getElementById("energyProductionChart")
        ) {
          energyProductionChart = initEnergyProductionChart();

          // Listen for period change events
          energyProductionChartElement.addEventListener(
            "period-change",
            function (e) {
              if (energyProductionChart) {
                handlePeriodChange(energyProductionChart, e.detail);
              }
            }
          );

          // Listen for filter events
          energyProductionChartElement.addEventListener(
            "remove-filter",
            function (e) {
              if (energyProductionChart) {
                removeFilter(energyProductionChart, e.detail);
              }
            }
          );

          energyProductionChartElement.addEventListener(
            "clear-filters",
            function () {
              if (energyProductionChart) {
                clearAllFilters(energyProductionChart);
              }
            }
          );
        }

        // Energy Prediction Chart initialization
        if (
          energyPredictionChartElement &&
          document.getElementById("energyPredictionChart")
        ) {
          predictionChart = initPredictionChart();

          // Listen for fetch data events
          energyPredictionChartElement.addEventListener(
            "fetch-data",
            function (e) {
              if (predictionChart) {
                fetchPredictionData(predictionChart, e.detail);
              }

              // Update Alpine.js state
              if (
                energyPredictionChartElement._x_dataStack &&
                energyPredictionChartElement._x_dataStack[0]
              ) {
                energyPredictionChartElement._x_dataStack[0].isLoading = true;
              }
            }
          );
        }

        // Power Distribution Chart initialization
        if (
          powerDistributionChartElement &&
          document.getElementById("powerDistributionChart")
        ) {
          powerDistributionChart = initPowerDistributionChart();

          // Listen for deselect segment events
          powerDistributionChartElement.addEventListener(
            "deselect-segment",
            function () {
              if (powerDistributionChart) {
                deselectSegment(powerDistributionChart);
              }
            }
          );
        }

        // Handle resize events for all charts
        window.addEventListener("resize", function () {
          if (
            energyProductionChart &&
            typeof energyProductionChart.resize === "function"
          ) {
            energyProductionChart.resize();
          }

          if (predictionChart && typeof predictionChart.resize === "function") {
            predictionChart.resize();
          }

          if (
            powerDistributionChart &&
            typeof powerDistributionChart.resize === "function"
          ) {
            powerDistributionChart.resize();
          }
        });
      } catch (error) {
        console.error("Error initializing charts:", error);
      }
    }
  });

  // Event handler functions
  function handlePeriodChange(chart, period) {
    console.log("Period change", period);

    // Get the Alpine data context
    const productionEl = document.getElementById("energy-production-chart");
    if (
      !productionEl ||
      !productionEl._x_dataStack ||
      !productionEl._x_dataStack[0]
    ) {
      console.warn("Production chart Alpine data not found");
      return;
    }

    // Update the chart with new period data
    if (window.EnergyDataUtils && chart) {
      const today = new Date();
      const data = window.EnergyDataUtils.generateEnergyData(period, 10, today);

      // Update chart datasets
      chart.data.labels = data.labels;
      chart.data.datasets[0].data = data.datasets.production;

      // Generate previous period data
      let prevDate;
      switch (period) {
        case "day":
          prevDate = new Date();
          prevDate.setDate(prevDate.getDate() - 1);
          break;
        case "week":
          prevDate = new Date();
          prevDate.setDate(prevDate.getDate() - 7);
          break;
        case "month":
          prevDate = new Date();
          prevDate.setMonth(prevDate.getMonth() - 1);
          break;
        case "year":
          prevDate = new Date();
          prevDate.setFullYear(prevDate.getFullYear() - 1);
          break;
      }

      const prevData = window.EnergyDataUtils.generateEnergyData(
        period,
        9.5,
        prevDate
      );
      chart.data.datasets[1].data = prevData.datasets.production;

      // Update the chart
      chart.update();

      // Update Alpine.js data
      const totalProduction = data.totals.production;
      productionEl._x_dataStack[0].summaryText = `Total ${period}: <strong>${totalProduction} kWh</strong>`;

      const prevTotal = prevData.totals.production;
      const diffPercent = (
        ((totalProduction - prevTotal) / prevTotal) *
        100
      ).toFixed(1);
      productionEl._x_dataStack[0].periodComparison = `${
        diffPercent > 0 ? "+" : ""
      }${diffPercent}% from previous ${period}`;
    }
  }

  function removeFilter(chart, filterId) {
    console.log("Remove filter", filterId);
    // Get the Alpine data context
    const productionEl = document.getElementById("energy-production-chart");

    if (
      productionEl &&
      productionEl._x_dataStack &&
      productionEl._x_dataStack[0]
    ) {
      // Update the filters array
      const filters = productionEl._x_dataStack[0].filters;
      const updatedFilters = filters.filter((filter) => filter.id !== filterId);
      productionEl._x_dataStack[0].filters = updatedFilters;

      // Update chart display based on active filters
      applyFiltersToChart(chart, updatedFilters);
    }
  }

  function clearAllFilters(chart) {
    console.log("Clear all filters");
    // Get the Alpine data context
    const productionEl = document.getElementById("energy-production-chart");

    if (
      productionEl &&
      productionEl._x_dataStack &&
      productionEl._x_dataStack[0]
    ) {
      // Clear the filters array
      productionEl._x_dataStack[0].filters = [];

      // Restore the chart to its original state
      if (chart) {
        const period = productionEl._x_dataStack[0].activePeriod;
        handlePeriodChange(chart, period);
      }
    }
  }

  function applyFiltersToChart(chart, filters) {
    // This is a placeholder for filter application logic
    // In a real implementation, you would modify chart data based on filter criteria
    if (chart && filters.length > 0) {
      // Example: Apply a simple scale factor based on filter count
      const scaleFactor = 1 - filters.length * 0.1;

      for (let i = 0; i < chart.data.datasets[0].data.length; i++) {
        chart.data.datasets[0].data[i] *= scaleFactor;
      }

      chart.update();
    }
  }

  function fetchPredictionData(chart, days) {
    console.log("Fetch prediction data for", days, "days");

    // Get the Alpine data context
    const predictionEl = document.getElementById("energy-prediction-chart");
    if (
      !predictionEl ||
      !predictionEl._x_dataStack ||
      !predictionEl._x_dataStack[0]
    ) {
      console.warn("Prediction chart Alpine data not found");
      return;
    }

    // Simulate API fetch with our utility
    if (window.EnergyDataUtils && chart) {
      const today = new Date();

      // Generate labels (dates)
      const labels = Array.from({ length: days }, (_, i) => {
        const date = new Date();
        date.setDate(date.getDate() + i);
        return date.toLocaleDateString("en-US", {
          month: "short",
          day: "numeric",
        });
      });

      // Get seasonal factor for more realistic prediction
      const month = today.getMonth();
      const seasonalFactor = window.EnergyDataUtils.getSeasonalFactor(month);

      // Generate prediction data
      const predictionData = labels.map((_, index) => {
        const dayFactor = 1 + Math.sin((index / days) * Math.PI) * 0.2;
        const randomFactor = 0.9 + Math.random() * 0.2;
        const weatherFactor = Math.random() > 0.7 ? 0.7 : 1;

        return +(
          seasonalFactor *
          10 *
          dayFactor *
          randomFactor *
          weatherFactor
        ).toFixed(2);
      });

      // Generate historical data (only for past days)
      const historicalData = labels.map((_, index) => {
        if (index < 2) {
          const dayFactor = 1 + Math.sin((index / days) * Math.PI) * 0.2;
          const randomFactor = 0.9 + Math.random() * 0.2;
          return +(seasonalFactor * 10 * dayFactor * randomFactor).toFixed(2);
        }
        return null; // No historical data for future days
      });

      // Generate confidence intervals
      const confidenceLow = predictionData.map(
        (val) => +(val * 0.8).toFixed(2)
      );
      const confidenceHigh = predictionData.map(
        (val) => +(val * 1.2).toFixed(2)
      );

      // Update chart
      chart.data.labels = labels;
      chart.data.datasets[0].data = predictionData;
      chart.data.datasets[1].data = historicalData;
      chart.data.datasets[2].data = confidenceLow;
      chart.data.datasets[3].data = confidenceHigh;
      chart.update();

      // Update Alpine.js data
      const total = predictionData
        .reduce((sum, val) => sum + val, 0)
        .toFixed(2);
      predictionEl._x_dataStack[0].totalPrediction = total;
      predictionEl._x_dataStack[0].isLoading = false;
    }
  }

  function deselectSegment(chart) {
    console.log("Deselect segment");

    if (chart && typeof chart.dispatchAction === "function") {
      chart.dispatchAction({
        type: "downplay",
        seriesIndex: 0,
      });
    }
  }
</script>
